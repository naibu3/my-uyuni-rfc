- Feature Name: CVE auditing with VEX
- Start Date: 2025-02-19

# Summary
[summary]: #summary

Use VEX in addition to existing implementation to increment CVE auditing accuracy. 

# Motivation
[motivation]: #motivation

In a world constantly endangered by security flaws it is crucial to detect threats in order to secure our systems. However detection systems may detect false positives from products that use vulnerable libraries but do not use vulnerable functions. Or even not detecting produts whose vulnerabilities are not patched yet.

Due to this, many companies like Red Hat are adopting **VEX** (*Vulnerability Exploitability eXchange*) [^1]. This format allows to clasify CVEs affecting a product by the terms **Fixed**, **Known Affected**, **Known Not Affected** and **Under Investigation**. This way it is possible to improve accuracy and discard false detections.

The aim is to polish CVE auditing, simplifying administration and keeping Uyuni up to date with the market standards.

# Detailed design
[design]: #detailed-design

The implementation for VEX will follow a similar structure as existing OVAL one [^2]. Here is a diagram to ilustrate the modules structure:

TODO - Create diagram

Mainly we will have two main objectives: **VEX data storaging/processing** and **CVE analysis**.

## VEX Data Storage and Processing

### VEX Downloader

Retrieve VEX documents online. Is responsible finding, downloading and caching the files, like was done for OVAL [^2].

Each supported distribution has a repository with VEX files (usually on *JSON* or *CSAF* format) where the module will download the data from. However, URLs will not be hardcoded, enabling any user to change the default source. For example in case of using a proxy.

#### Synchronization

To ensure accuracy is crucial to keep VEX data up-to-date, so data have to be synchronized periodically. The time ammount needed for performing this opperation will deppend on how many operating systems are being used. For instance, in case the user uses a single OS it will take just a few second, which differs with the case of using 20 different OOSS.

Anyway syncronizing VEX data **once a day** on low workload hours may be a good default, but it will be possible for the user to change it.

In certain cases, downloading all data can be redundant as it did not change since last sync. For that reason, many repositories include a manifest file that contains hashes for VEX files. Comparing those hashes with local files before downloadings will improve efficiency. For those cases when there is no manifest file, it is possible to perform a html scrapping to decide if data should be downloaded.

### VEX Parser

VEX file are usually on JSON or CSAF format so is needed to translate them into POJO format in order to use its data. Despite the files come from trusted sources, they will be validated to ensure they contain correct and non-malicious data.

### VEX DAO

It provides an interface to work with the VEX data. Is the only way to query or modify the information from the database.

### DB Storage

As VEX data contains additional fields (like *analysis status*, *justification*, and *recommended response*), we need new tables to store and query this extra metadata:

## CVE enhanced analysis

TODO

## API Access

TODO

# Drawbacks
[drawbacks]: #drawbacks

Why should we **not** do this?

  * will it impact performance?

# Alternatives
[alternatives]: #alternatives

# Unresolved questions
[unresolved]: #unresolved-questions

- Is it possible to use same database tables as OVAL uses? [^2]
- Should be taken into consideration data from the legacy system (OVAL) if VEX is available?

# References
[references]: #references

[^1]: [The Future of Red Hat Security Data](https://www.redhat.com/en/blog/future-red-hat-security-data)
[^2]: [CVE Auditing with OVAL](https://urldefense.com/v3/__https://github.com/uyuni-project/uyuni-rfc/pull/80__;!!D9dNQwwGXtA!X5VPAqQnoak6vx4dsUErkpGohMhPg4gLYeBXbT5Ith8UQwCd2TNWkXtTAG786GipiVEsxTxTc3W2xmM$)
